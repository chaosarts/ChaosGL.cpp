//
//  geom.hpp
//  ChaosGL
//
//  Created by Fu Lam Diep on 12.03.16.
//  Copyright Â© 2016 Fu Lam Diep. All rights reserved.
//

#ifndef ChaosGL_geom_hpp_
#define ChaosGL_geom_hpp_

#include <vector>
#include <glm/glm.hpp>
#include <OpenGL/OpenGL.h>
#include <OpenGL/gl3.h>
#include "attrib.hpp"
#include "primitive.hpp"

namespace chaosgl
{
	template<typename T, glm::precision P = glm::defaultp>
	struct tgeom : public virtual tattrib_countable<glm::tvec3<T, P>>
	{
	private:
		/// Provides the x, y or z value of the farmost left, right, bottom, top, near and far points
		T _left, _right, _bottom, _top, _near, _far;
	public:
		
		/// Returns the count of primitives, which can be
		/// generated by this geometry
		int getPrimitiveCount (int primitve_size) const
		{
			return (int) this->count(GL_ARRAY_BUFFER) / primitve_size;
		}
		
		
		/// Returns the count of triangles, which can possibly
		/// be generated by this geometry
		int getTriangleCount () const
		{
			return getPrimitiveCount(3);
		}
		
		
		/// Returns the according triangle at given index
		t_triangle<T, P> getTriangle (int index) const
		{
			const int count = getTriangleCount();
			const int start_index = index * 3;
			if (start_index < 0 || start_index + 2 >= count) throw "<geom> Could not get triangle for index";
			
			glm::tvec3<T, P> a = this->getValue(start_index, GL_ARRAY_BUFFER);
			glm::tvec3<T, P> b = this->getValue(start_index + 1, GL_ARRAY_BUFFER);
			glm::tvec3<T, P> c = this->getValue(start_index + 2, GL_ARRAY_BUFFER);
			
			return t_triangle<T, P>(a, b ,c);
		}
		
		
		/// Returns the count of quads, which can possibly
		/// be generated by this geometry
		int getQuadCount () const
		{
			return getPrimitiveCount(4);
		}
		
		
		/// Returns the according quad at given index
		t_quad<T, P> getQuad (int index) const
		{
			const int count = getQuadCount();
			const int start_index = index * 4;
			if (start_index < 0 || start_index + 3 >= count) throw "<geom> Could not get triangle for index";
			
			glm::tvec3<T, P> a = this->getValue(start_index, GL_ARRAY_BUFFER);
			glm::tvec3<T, P> b = this->getValue(start_index + 1, GL_ARRAY_BUFFER);
			glm::tvec3<T, P> c = this->getValue(start_index + 2, GL_ARRAY_BUFFER);
			glm::tvec3<T, P> d = this->getValue(start_index + 3, GL_ARRAY_BUFFER);
			
			return t_quad<T, P>(a, b, c, d);
		}
		
		
		virtual void addValue (glm::tvec3<T, P> value)
		{
			if (this->count() == 0)
			{
				_left = value.x;
				_right = value.x;
				_bottom = value.y;
				_top = value.y;
				_near = value.z;
				_far = value.z;
			}
			else
			{
				_left = std::min(value.x, _left);
				_right = std::max(value.x, _right);
				_bottom = std::min(value.y, _bottom);
				_top = std::max(value.y, _top);
				_near = std::min(value.z, _near);
				_far = std::max(value.z, _far);
			}
			
			tattrib_list<glm::tvec3<T, P>>::addValue(value);
		}
	};
	
	typedef tgeom<glm::tvec3<float, glm::lowp>> lowp_geom;
	typedef tgeom<glm::tvec3<float, glm::mediump>> mediump_geom;
	typedef tgeom<glm::tvec3<float, glm::highp>> highp_geom;
	typedef highp_geom geom;
}
#endif
